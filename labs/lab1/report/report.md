---
## Front matter
title: "Отчёт по лабораторной работе №1"
subtitle: "Математическое моделирование"
author: "Бансимба Клодели Дьегра"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib


## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Целью данной работы является приобретение практических навыков установки операционной системы на виртуальную машину, настройки минимально необходимых для дальнейшей работы сервисов

# Выполнение лабораторной работы

## Подготовка
Если вы никогда ранее не использовали git, для начала вам необходимо осуществить установку. Выполните следующие команды, чтобы git узнал ваше имя и электронную почту (рис. @fig:001).. 

![становка имени и электронной почты](image/1.1.1.png){#fig:001 width=70%}

Сначала настроим core.autocrlf с параметрами true и input, чтобы сделать все переводы строк текстовых файлов в главном репозитории одинаковыми, а затем настроим отображение unicode (рис. @fig:002) и (рис. @fig:003) .

![араметры установки окончаний строк](image/1.1.2.png){#fig:002 width=70%}

![становка отображения unicode](image/1.1.3.png){#fig:003 width=70%}

## Создание проекта

Создадим пустой каталог hello, а в нём файл с именем hello.html. Затем создадим  git репозиторий из этого каталога, выполнив команду git init. Добавим файл в репозиторий и проверим статус, который сообщает, что коммитить нечего (рис. @fig:004), (рис. @fig:005).

![Создание репозитория](image/1.2.1.png){#fig:004 width=70%}

![Добавление файла в репозиторий](image/1.2.3.png){#fig:005 width=70%}

## Внесение изменений

Изменим содержимое файла hello.html на:

```
<h1>Hello, World!</h1>
```

Проверив состояние рабочего каталога увидим, что git знает, что файл hello.html был изменен, но при этом эти изменения еще не зафиксированы в репозитории. Теперь проиндексируем изменения и снова посмотрим статус, в нём указано, что изменения пока не записаны в резапозиторий. И наконец закоммитим изменения, внеся их в репозиторий и снова посмотрим статус, который теперь показывает, что все изменения внесены в репозиторий (рис. @fig:006) и (рис. @fig:007).

![Внесение изменений в содержимое репозитория](image/1.3.1.png){#fig:006 width=70%}

![Внесение изменений в содержимое репозитория](image/1.3.1.1.png){#fig:007 width=70%}

Изменим страницу «Hello, World», чтобы она содержала стандартные теги <html> и <body> (рис. @fig:008).

```
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
![обавьте стандартные теги страницы](image/1.4.2.png){#fig:008 width=70%} 

Теперь добавим это изменение в индекс git и добавим заголовки HTML (секцию <head>) к странице «Hello, World» (рис. @fig:009).

![обавьте стандартные теги страницы](image/1.4.2.1.png){#fig:009 width=70%} 

Проверив текущий статус увидим, что hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту. Второе изменение (добавление заголовков HTML) является непроиндексированным. Произведем коммит проиндексированного изменения, затем проиндексируем оставшееся изменение, посмотрим статус и прокоммитим его(рис. @fig:0010).

![Внесение нескольких изменений в содержимое репозитория](image/1.4.2.2.png){#fig:0010 width=70%}

## История
Получим список произведенных изменений (рис. @fig:0011): git log

![список произведенных изменений](image/1.4.3.png){#fig:0011 width=70%}

Однострочный формат истории: git log --pretty=oneline

Есть много вариантов отображения лога.

git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=clodeli bansimba
git log --pretty=oneline --all
 
![Однострочный формат истории и Есть много вариантов](image/1.4.3.1.png){#fig:0012 width=70%}

## Получение старых версий

Изучим данные лога и найдем там хэш первого коммита, используя его вернемся к первой верссии и просмотрим файл hello.html, действительно, увидим первую версию. Затем вернемся к последней версии в ветке master и вновь посмотрим на файл(рис. @fig:0013), (рис. @fig:0014).

![Просмотр разных версий репозитория](image/1.4.4.png){#fig:0013 width=70%}

![Просмотр разных версий репозитория](image/1.4.4.1.png){#fig:0014 width=70%}

## Создание тегов версий

Назовем текущую версию страницы hello первой (v1). Создадим тег первой версии и используем его для того чтобы венуться к предыдущей, которой также присвоим тег (рис. @fig:0015).

![Создание тегов версий](image/1.4.5.png){#fig:0015 width=70%}

Переключимся по тегам между двумя отмеченными версиями. Просмотрим все доступные теги(их два) и посмотрим теги в логе(рис. @fig:016).

![Переключение по имени тега и просмотр доступных тегов](image/1.4.7.png){#fig:016 width=70%}

## Отмена локальных изменений (до индексации)

Убдеимся, что мы находимся на последнем коммите ветки master (рис. @fig:017).

![Отмена локальных изменений (до индексации)](image/1.5.png){#fig:017 width=70%}

и внесем изменение в файл hello.html в виде нежелательного комментария (рис. @fig:018).

![изменение в файл](image/1.5.2.png){#fig:018 width=70%}

Затем проверим статус, увидим, что изменения ещё не проиндексированы (рис. @fig:019).

![изменение в файл](image/1.5.3.png){#fig:019 width=70%}

Используем команду git checkout для переключения версии файла hello.html в репозитории (рис. @fig:020).

![git checkout](image/1.5.4.png){#fig:020 width=70%}

## Отмена проиндексированных изменений (перед коммитом)
### Измените файл и проиндексируйте изменения
Внесем изменение в файл hello.html в виде нежелательного комментария (рис. @fig:021).

```
<html>
  <head>
    <!-- This is an unwanted but staged comment -->
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
![изменение в файл hello.html](image/1.6.1.png){#fig:021 width=70%}

Проиндексируем это изменение и проверим состояние (рис. @fig:022).
git status  

![git status](image/1.6.2.png){#fig:022 width=70%}

Состояние показывает, что изменение было проиндексировано и готово к коммиту. Используем команду git reset, чтобы сбросить буферную зону к HEAD. Это очищает буферную зону от изменений, которые мы только что проиндексировали. И переключимся на последнюю версию коммита, посмотрев статус увидим, что наш каталог опять чист (рис. @fig:023),  (рис. @fig:024).

![Отмена проиндексированных изменений (перед коммитом)](image/1.6.3.png){#fig:023 width=70%}

![Отмена проиндексированных изменений (перед коммитом)](image/1.6.4.png){#fig:024 width=70%}


## Отмена коммитов

Изменим файл hello.html на следующий (рис. @fig:025) (рис. @fig:026).

```
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
    <!-- This is an unwanted but committed change -->
  </body>
</html>
```
![Изменим файл hello.html](image/1.7.2.png){#fig:025 width=70%}

![Изменим файл hello.html](image/1.7.2.1.png){#fig:026 width=70%}

Проиндексируем изменения файла и прокоммитим их. Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом. Перейдем в редактор, где изменим нежелательный коммит. Проверим лог. Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий(рис. @fig:027).

![Отмена коммитов](image/1.7.4.png){#fig:027 width=70%}

## Удаление коммиттов из ветки

Удалим последние два коммита с помощью сброса, сначала отметим последний коммит тегом, чтобы его можно было потом найти. Используем команду git reset, чтобы вернуться к версии до этих коммитов. Теперь в логе их нет, но если посмотреть логи с опцией  --all можно всё ещё их увидеть, но метка HEAD находится на нужной нам версии.

![Удаление коммиттов из ветки](image/1.8.4.png){#fig:028 width=70%}

![Удаление коммиттов из ветки](image/1.8.5.png){#fig:029 width=70%}

## Удаление тега oops

Удалим тег oops и коммиты, на которые он ссылался, сборщиком мусора. Теперь этот тег не отображается в репозитории.

![Удаление тега oops](image/1.9.1.png){#fig:030 width=70%}

## Внесение изменений в коммиты
### Измените страницу, а затем сделайте коммит

Добавим в страницу комментарий автора (рис. @fig:031)

![автора](image/1.10.1.png){#fig:031 width=70%}

![Commit](image/1.10.1.1.png){#fig:032 width=70%}

### Необходим email
комментарий должен включать электронную почту автора (рис. @fig:033).

![Email](image/1.10.2.png){#fig:033 width=70%}

![Email](image/1.10.3.png){#fig:034 width=70%}

## Просмотр истории
git log

![Email](image/1.10.4.png){#fig:035 width=70%}

Мы можем увидеть, что оригинальный коммит «автор» заменен коммитом «автор/email». Этого же эффекта можно достичь путем сброса последнего коммита в ветке, и повторного коммита новых изменений (рис. @fig:035).

## Перемещение файлов

Переместим наш файл в каталог lib. Для этого создадим его и используем команду git mv, сделаем коммит этого пермещения (рис. @fig:036).

![Перемещение файлов](image/1.11.1.png){#fig:036 width=70%}

## Второй способ перемещения файлов

![Второй способ перемещения файлов](image/1.12.png){#fig:037 width=70%}

сделаем коммит этого перемещения (рис. @fig:038)

![Коммит в новый каталог](image/1.12.1.png){#fig:038 width=70%}

## Подробнее о структуре

Добавим файл index.html в наш репозиторий (рис. @fig:039)

```
<html>
  <body>
    <iframe src="lib/hello.html" width="200" height="200" />
  </body>
</html>
```
![index.html](image/1.13.1.png){#fig:039 width=70%}

Добавим файл и сделаем коммит (рис. @fig:040).

![коммит](image/1.13.1.1.png){#fig:040 width=70%}

Теперь при открытии index.html, увидим кусок страницы hello в маленьком окошке .

![Результат открытия index.html](image/1.13.1.1.1.png){#fig:041 width=70%}

## Git внутри: Каталог .git
### Каталог .git
ls -C .git
Это каталог, в котором хранится вся информация git (рис. @fig:042).

![информация git](image/1.14.1.png){#fig:042 width=70%}

### База данных объектов
ls -C .git/objects

![информация git](image/1.14.2.png){#fig:043 width=70%}

### глубляемся в базу данных объектов
ls -C .git/objects/<dir>
Смотрим в один из каталогов с именем из 2 букв. Вы увидите файлы с именами из 38 символов. Это файлы, содержащие объекты, хранящиеся в git. Они сжаты и закодированы, поэтому просмотр их содержимого нам мало чем поможет (рис. @fig:044).

![глубляемся в базу данных объектов](image/1.14.3.png){#fig:044 width=70%}

### Config File
cat .git/config
Это файл конфигурации, создающийся для каждого конкретного проекта. Записи в этом файле будут перезаписывать записи в файле .gitconfig вашего главного каталога, по крайней мере в рамках этого проекта (рис. @fig:045).

![Config File](image/1.14.4.png){#fig:045 width=70%}

### Ветки и теги
узнавать файлы в подкаталоге тегов. Каждый файл соответствует тегу, ранее созданному с помощью команды git tagЕго содержание — это всего лишь хэш коммита, привязанный к тегу(рис. @fig:046).

![Ветки и теги](image/1.14.5.png){#fig:046 width=70%}

### Файл HEAD
cat .git/HEAD
Файл HEAD содержит ссылку на текущую ветку, в данный момент это должна быть ветка master (рис. @fig:047)

![Файл HEAD](image/1.14.6.png){#fig:047 width=70%}

## Работа непосредственно с объектами git

Найдем последний коммит и выедем его с помощью  SHA1 хэша. Затем посмотрим дерево каталогов, ссылка на который идёт в последнем коммите, вывдем каталог lib и файл  hello.html(рис. @fig:047).

![Работа непосредственно с объектами git](image/1.15.png){#fig:47 width=70%}

Исследуем  git репозиторий вручную самостоятельно. Используя хэш родительского коммита последовательно дойдем до первой версии файла hello.html и посмотрим его.

## Создание ветки

Создадим новую ветку «style» и перейдем в неё. Добавим туда файл стилей style.css и добавим его в репозиторий. Обновим файл hello.html, чтобы использовать стили style.css и index.html, также обновим их в репозиторий . 

![Создание ветки](image/1.16.1.png){#fig:048 width=70%}

добавим файл стилей style.css

![добавим файл стилей ](image/1.16.2.png){#fig:049 width=70%}

![добавим файл стилей ](image/1.16.2.1.png){#fig:050 width=70%}

Обновим файл hello.html

![Редактирование файла](image/1.16.3.png){#fig:051 width=70%}

![Редактирование файла](image/1.16.3.1.png){#fig:052 width=70%}

## Навигация по веткам

Посмотрим все логи(рис. @fig:053).

![Просмотр логов новой ветки](image/1.17.png){#fig:053 width=70%}

Переключимся обратно на основную ветку и просмотрим содержимое файла ib/hello.html, заметим, что он не использует стили, также просмотрим содержимое этого файла в новой ветке(рис. @fig:054-@fig:055).

![Переключение на ветку master](image/1.17.1.png){#fig:054 width=70%}

![Возвращение к ветке style](image/1.17.2.png){#fig:055 width=70%}

## Изменения в ветке master

Вернемся в основную ветку и добавим файл  README.md. Просмотрим ветки и их различия(рис. @fig:056).

![Изменения в ветке master](image/1.18.1.png){#fig:056 width=70%}

## Просмотрите текущие ветки
Сделайте коммит изменений README.md в ветку master.

![коммит](image/1.19.1.png){#fig:057 width=70%}

для просмотра веток и их отличий.

![для просмотра веток и их отличий](image/1.19.2.png){#fig:058 width=70%}

## Слияние

Слияние переносит изменения из двух веток в одну. Вернемся к ветке style и сольем master с style(рис. @fig:059).

![Слияние веток](image/1.20.1.png){#fig:059 width=70%}


## Создание конфликта

Вернемся в ветку master и создадим конфликт, внеся изменения в файл hello.html (рис. @fig:060). 

![Создание конфликта](image/1.21.1.png){#fig:060 width=70%}

![Создание конфликта](image/1.21.1.1.png){#fig:061 width=70%}

Просмотрим ветки. После коммита «Added README» ветка master была объединена с веткой style, но в настоящее время в master есть дополнительный коммит, который не был слит с style. Последнее изменение в master конфликтует с некоторыми изменениями в style(рис. @fig:062).

![Просмотр веток](image/1.21.2.png){#fig:062 width=70%}

## Разрешение конфликтов
### Слияние master с веткой style
Вернемся к ветке style и попытаемся объединить ее с новой веткой master. В файле lib/hello.html можно увидеть записи с обеих версий этого файла. Первый раздел — версия текущей ветки (style). Второй раздел — версия ветки master (рис. @fig:063) .

![Конфликт](image/1.22.1.png){#fig:063 width=70%}

Внесем изменения в lib/hello.html, оставив только необходимую нам запись и добавим этот файл в репозиторий, чтобы вручную разрешить конфликт (рис. @fig:064).

![Конфликт](image/1.22.2.png){#fig:064 width=70%}

![Разрешение конфликта](image/1.22.3.png){#fig:065 width=70%}

## Сброс ветки style

Вернемся на ветке style к точке перед тем, как мы слили ее с веткой master. Мы хотим вернуться в ветке style в точку перед слиянием с master. Нам необходимо найти последний коммит перед слиянием (рис. @fig:066).

![Поиск коммита перед слиянием](image/1.23.1.png){#fig:066 width=70%}

Мы видим, что коммит «Updated index.html» был последним на ветке style перед слиянием. Сбросим ветку style к этому коммиту.

![Поиск коммита перед слиянием](image/1.23.1.1.png){#fig:067 width=70%}

Поищим лог ветки style. Увидим, что у нас в истории больше нет коммитов слияний(рис. @fig:068).

![Сброс ветки style](image/1.23.2.png){#fig:068 width=70%}

## Сброс ветки master

Добавив интерактивный режим в ветку master, мы внесли изменения, конфликтующие с изменениями в ветке style. Давайте вернемся в ветке master в точку перед внесением конфликтующих изменений. Это позволяет нам продемонстрировать работу команды git rebase, не беспокоясь о конфликтах. Просмотрим коммиты ветки master(рис. @fig:069).

![Поиск коммита перед конфликтом](image/1.24.1.png){#fig:069 width=70%}

Коммит «Added README» идет непосредственно перед коммитом конфликтующего интерактивного режима. Мы сбросим ветку master к коммиту «Added README»(рис. @fig:070).

![Сброс ветки master](image/1.24.1.1.png){#fig:070 width=70%}

## Перебазирование

Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style. На этот раз для переноса изменений из ветки master мы будем использовать команду git rebase вместо слияния(рис. @fig:071).

![Перебазирование](image/1.25.png){#fig:071 width=70%}

## Слияние в ветку master
 
Вернемся в ветку master и сольем ветку style в неё с помощью команды git merge(рис. @fig:072).

![Слияние style в master](image/1.26.1.png){#fig:072 width=70%}

Теперь ветки style и master идентичны (рис. @fig:073).

![Слияние style в master](image/1.26.2.png){#fig:073 width=70%}

## Клонирование репозиториев

Перейдем в наш рабочий каталог и сделаем клон репозитория hello, затем создадим клон репозитория. Просмотрев его увидим список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib. Затем просмотрим историю репозитория и увидим список всех коммитов в новый репозиторий, и он совпадает с историей коммитов в оригинальном репозитории. Единствен в названиях веток (рис. @fig:074) и (рис. @fig:075).

![Клонирование репозиториев](image/1.27.1.png){#fig:074 width=70%}

![Клонирование репозиториев](image/1.27.2.png){#fig:075 width=70%}

## Что такое origin?

Клонированный репозиторий знает об имени по умолчанию удаленного репозитория. Посмотрим, подробную информацию об имени по умолчанию.Для того, чтобы увидеть все ветки используем опцию -a (рис. @fig:076).

![Просмотр имени по умолчанию удаленного репозитория](image/1.29.png){#fig:076 width=70%}

## Удаленные ветки

Посмотрим на ветки, доступные в нашем клонированном репозитории. Можно увидеть, что в списке только ветка master (рис. @fig:077).

![Удаленные ветки](image/1.30.png){#fig:077 width=70%}

Для того, чтобы увидеть все ветки (рис. @fig:078)

![Удаленные ветки](image/1.30.png){#fig:078 width=70%}

## Изменение оригинального репозитория

Перейдем в репозиторий hello. Внесем изменения в файл README.md. Затем добавим их в репозиторий (рис. @fig:079).

![Изменение оригинального репозитория](image/1.31.1.png){#fig:079 width=70%}

Перейдём в клон репозитория и используем команду git fetch, которая будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с наработками в локальных ветках(рис. @fig:080).

![Извлечение изменений](image/1.31.2.png){#fig:080 width=70%}

Мы можем продемонстрировать, что клонированный файл README.md не изменился (рис. @fig:081).

![Извлечение изменений](image/1.31.3.png){#fig:081 width=70%}

## Слияние извлеченных изменений

Сольем внесённые изменения в главную ветку. 

![Слияние извлеченных изменений](image/1.32.1.png){#fig:082 width=70%}

Также можно было бы использовать команду git pull, которая является объединением fetch и merge в одну команду (рис. @fig:083), (рис. @fig:084).

![Слияние извлеченных изменений](image/1.32.2.png){#fig:083 width=70%}

![Слияние извлеченных изменений](image/1.32.2.1.png){#fig:084 width=70%}

## Добавление ветки наблюдения

Добавим локальную ветку, которая отслеживает удаленную ветку, теперь мы можем видеть ветку style в списке веток и логе(рис. @fig:085).

![Добавление ветки наблюдения](image/1.33.1.png){#fig:085 width=70%}

## Создание чистого репозитория

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Создадим такой в рабочем каталоге. Затем добавим репозиторий  hello.git к нашему оригинальному репозиторию(рис. @fig:086).

![Создание чистого репозитория](image/1.35.png){#fig:086 width=70%}

## Добавление удаленного репозитория

добавим репозиторий hello.git к нашему оригинальному репозиторию (рис. @fig:087).

![добавим репозиторий hello.git](image/1.36.png){#fig:087 width=70%}


## Отправка и извлечение изменений 

Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории. Начнем с создания изменения для отправки. Отредактируем файл README.md и сделаем коммит, затем отправим изменения в общий репозиторий (рис. @fig:088, @fig:089).

![Отправка изменений](image/1.37.png){#fig:088 width=70%}

![Отправка изменений](image/1.37.1.png){#fig:089 width=70%}

Затем извлечем изменения из общего репозитория (рис. @fig:089).

![Извлечение изменений](image/1.38.png){#fig:090 width=70%}


# Выводы

В процессе выполнения данной лабораторной работы я приобрел практические навыки работы с Git.

# Список литературы{.unnumbered}

::: {#refs}
:::
